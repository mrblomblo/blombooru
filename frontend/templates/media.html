{% extends "base.html" %}

{% block title %}Media - {{ app_name }}{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-4">
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-4">
        <!-- Media Content -->
        <div class="lg:col-span-3">
            <div class="surface p-4 border">
                <div id="media-container" class="text-center"></div>
            </div>
            
            <!-- Related Media -->
            <div class="surface mt-4 p-4 border">
                <h2 class="text-base font-bold mb-3 pb-2 border-b">Related Media</h2>
                <div id="related-media" class="grid grid-cols-4 md:grid-cols-6 gap-2"></div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="lg:col-span-1">
            <!-- Information -->
            <div class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">Information</h3>
                <div id="media-info-content" class="text-xs"></div>
            </div>
            
            <!-- Tags -->
            <div class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">Tags</h3>
                <div id="tags-container"></div>
                
                <!-- Edit Tags (Admin Mode Only) -->
                <div id="edit-tags-section" style="display: none;" class="pt-3 border-t">
                    <form id="edit-tags-form">
                        <label class="block text-xs font-bold mb-2">Edit Tags</label>
                        <div class="mb-2" style="position: relative;">
                            <div id="tags-input" contenteditable="true" data-placeholder="original highres cat_ears" class="w-full bg px-2 py-1 border text-xs focus:outline-none focus:border-primary" style="min-height: 1.5rem; white-space: pre-wrap; overflow-wrap: break-word;"></div>
                        </div>
                        <button type="button" id="append-ai-tags-btn" class="w-full px-3 py-1 surface-light hover:surface-light text text-xs mb-2" style="display: none;">Append AI Tags</button>
                        <button type="submit" class="w-full px-3 py-1 bg-primary primary-text hover:bg-primary text-xs">Save Tags</button>
                    </form>
                </div>
            </div>

            <!-- AI Metadata (if present) -->
            <div id="ai-metadata-section" style="display: none;" class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">AI Generation Data</h3>
                <div id="ai-metadata-content" class="text-xs"></div>
            </div>
            
            <!-- Actions -->
            <div class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">Actions</h3>
                
                <div class="space-y-3">
                    <a id="download-btn" href="#" download class="block w-full px-3 py-1 surface-light hover:surface-light text text-center text-xs">Download</a>
                    
                    <!-- Admin Actions -->
                    <div id="admin-actions" style="display: none;" class="space-y-2 pt-2 border-t">
                        <label class="block text-xs font-bold mb-1">Rating</label>
                        <select id="rating-select" class="w-full bg px-2 py-1 border text-xs mb-2 focus:outline-none focus:border-primary">
                            <option value="safe">Safe</option>
                            <option value="questionable">Questionable</option>
                            <option value="explicit">Explicit</option>
                        </select>
                        
                        <button id="share-btn" class="w-full px-3 py-1 bg-primary primary-text hover:bg-primary text-xs">Share</button>
                        <button id="delete-btn" class="w-full px-3 py-1 bg-danger hover:bg-danger tag-text text-xs">Delete</button>
                    </div>
                </div>
            </div>
            
            <!-- Share Link Display -->
            <div id="share-link-section" style="display: none;" class="bg-primary primary-text p-3 border border-primary mb-4">
                <h4 class="text-sm font-bold mb-2 primary-text">Share Actions</h4>
                <div id="ai-metadata-share-toggle" class="mb-2 p-2 surface border" style="display: none;">
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-xs text font-medium">Include AI metadata</span>
                        <div class="relative">
                            <input type="checkbox" id="share-ai-metadata-toggle" class="sr-only peer">
                            <div class="w-9 h-5 surface-light peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-[var(--primary-color)] rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-[var(--primary-text)] after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-[var(--text)] after:border-[var(--surface-light)] after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-[var(--primary-color)] peer-checked:after:bg-[var(--primary-text)]"></div>
                        </div>
                    </label>
                </div>
                <input type="text" id="share-link-input" readonly class="w-full surface px-2 py-1 border focus:outline-none focus:border-primary text-xs text mb-2">
                <div class="space-y-1">
                    <button id="copy-share-link-btn" class="w-full px-3 py-1 surface hover:surface text text-xs">Copy Link</button>
                    <button id="unshare-btn" class="w-full px-3 py-1 surface-light hover:surface-light text text-xs" style="display: none;">Remove Share</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const mediaId = "{{ media_id }}";
        let currentMedia = null;

        const el = id => document.getElementById(id);

        // Tag validation system
        const tagValidationCache = new Map(); // tag -> boolean
        let validationTimeout = null;

        async function checkTagExists(tagName) {
            if (!tagName || !tagName.trim()) return true;
            const normalized = tagName.toLowerCase().trim();
            
            try {
                const res = await fetch(`/api/tags/${encodeURIComponent(normalized)}`);
                return res.ok;
            } catch (e) {
                console.error('Error checking tag:', e);
                return false;
            }
        }

        async function getTagOrAlias(tagName) {
            if (!tagName || !tagName.trim()) return null;
            const normalized = tagName.toLowerCase().trim();
            
            try {
                const res = await fetch(`/api/tags/${encodeURIComponent(normalized)}`);
                if (!res.ok) return null;
                
                const data = await res.json();
                // If it's an alias, return the target tag name, otherwise return the original
                return data.aliased_to || data.name;
            } catch (e) {
                console.error('Error fetching tag:', e);
                return null;
            }
        }

        function getPlainTextFromDiv(div) {
            return div.textContent || '';
        }

        function getCursorPosition(element) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return 0;
            
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            return preCaretRange.toString().length;
        }

        function setCursorPosition(element, offset) {
            const selection = window.getSelection();
            const range = document.createRange();
            
            let currentOffset = 0;
            let found = false;
            
            function traverseNodes(node) {
                if (found) return;
                
                if (node.nodeType === Node.TEXT_NODE) {
                    const nodeLength = node.textContent.length;
                    if (currentOffset + nodeLength >= offset) {
                        range.setStart(node, offset - currentOffset);
                        range.collapse(true);
                        found = true;
                        return;
                    }
                    currentOffset += nodeLength;
                } else {
                    for (let child of node.childNodes) {
                        traverseNodes(child);
                        if (found) return;
                    }
                }
            }
            
            try {
                traverseNodes(element);
                if (!found && element.lastChild) {
                    range.setStartAfter(element.lastChild);
                    range.collapse(true);
                }
                selection.removeAllRanges();
                selection.addRange(range);
            } catch (e) {
                console.error('Error setting cursor:', e);
            }
        }

        async function validateAndStyleTags() {
            const tagsInput = el('tags-input');
            if (!tagsInput) return;
            
            const text = getPlainTextFromDiv(tagsInput);
            const cursorPos = getCursorPosition(tagsInput);
            
            // Split by whitespace
            const parts = text.split(/(\s+)/);
            const tags = [];
            
            // Check each non-whitespace part
            for (let part of parts) {
                if (part.trim()) {
                    const normalized = part.trim().toLowerCase();
                    if (!tagValidationCache.has(normalized)) {
                        const exists = await checkTagExists(normalized);
                        tagValidationCache.set(normalized, exists);
                    }
                    tags.push({ text: part, isValid: tagValidationCache.get(normalized) });
                } else {
                    tags.push({ text: part, isWhitespace: true });
                }
            }
            
            // Build styled HTML
            let html = '';
            for (let tag of tags) {
                if (tag.isWhitespace) {
                    html += tag.text;
                } else if (tag.isValid === false) {
                    html += `<span class="invalid-tag">${tag.text}</span>`;
                } else {
                    html += tag.text;
                }
            }
            
            // Update content if changed
            if (tagsInput.innerHTML !== html) {
                tagsInput.innerHTML = html || '';
                setCursorPosition(tagsInput, cursorPos);
            }
        }

        function setupTagInput() {
            const tagsInput = el('tags-input');
            if (!tagsInput) return;
            
            // Handle input events
            tagsInput.addEventListener('input', () => {
                clearTimeout(validationTimeout);
                validationTimeout = setTimeout(validateAndStyleTags, 300);
            });
            
            // Immediate validation on space
            tagsInput.addEventListener('keyup', (e) => {
                if (e.key === ' ') {
                    clearTimeout(validationTimeout);
                    validateAndStyleTags();
                }
            });
            
            // Prevent default Enter behavior (creating new lines)
            tagsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                }
            });
            
            // Paste as plain text
            tagsInput.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = e.clipboardData.getData('text/plain');
                document.execCommand('insertText', false, text);
            });
        }

        async function loadMedia() {
            try {
                const res = await fetch(`/api/media/${mediaId}`);
                currentMedia = await res.json();
                renderMedia(currentMedia);
                renderInfo(currentMedia);
                renderTags(currentMedia);
                await renderAIMetadata(currentMedia);
                if (app.isAdminMode) {
                    el('edit-tags-section').style.display = 'block';
                    el('admin-actions').style.display = 'block';
                    el('ai-metadata-share-toggle').style.display = 'block';
                    el('unshare-btn').style.display = 'block';
                    setupTagInput();
                    
                    // Initialize tag autocomplete with contenteditable support
                    const tagsInput = document.getElementById('tags-input');
                    if (tagsInput) {
                        new TagAutocomplete(tagsInput, {
                            multipleValues: true,
                            onSelect: () => {
                                // Trigger validation after autocomplete selection
                                setTimeout(validateAndStyleTags, 100);
                            }
                        });
                    }
                }
                if (currentMedia.is_shared) {
                    showShareLink(currentMedia.share_uuid, currentMedia.share_ai_metadata);
                }
                await loadRelatedMedia();
            } catch (e) {
                console.error('loadMedia error', e);
            }
        }

        function renderMedia(media) {
            const c = el('media-container');
            c.innerHTML = media.file_type === 'video'
                ? `<video controls loop><source src="/api/media/${media.id}/file" type="${media.mime_type}"></video>`
                : `<img src="/api/media/${media.id}/file" alt="${media.filename}">`;
            el('download-btn').href = `/api/media/${media.id}/file`;
            el('download-btn').download = media.filename;
        }

        function renderInfo(m) {
            el('media-info-content').innerHTML = `
                <div class="info-row"><span>Filename</span><strong>${m.filename}</strong></div>
                <div class="info-row"><span>Type</span><strong>${m.file_type}</strong></div>
                <div class="info-row"><span>Size</span><strong>${formatFileSize(m.file_size)}</strong></div>
                <div class="info-row"><span>Dimensions</span><strong>${m.width}x${m.height}</strong></div>
                <div class="info-row"><span>Rating</span><strong>${m.rating}</strong></div>
                <div class="info-row"><span>Uploaded</span><strong>${new Date(m.uploaded_at).toLocaleDateString()}</strong></div>
                ${m.duration ? `<div class="info-row"><span>Duration</span><strong>${formatDuration(m.duration)}</strong></div>` : ''}
            `;
            const sel = el('rating-select');
            if (sel) sel.value = m.rating;
        }

        function renderTags(m) {
            const c = el('tags-container');
            const groups = { artist: [], character: [], copyright: [], general: [], meta: [] };
            (m.tags || []).forEach(t => groups[t.category]?.push(t));
            let html = '';
            Object.entries(groups).forEach(([cat, tags]) => {
                if (!tags.length) return;
                tags.sort((a, b) => a.name.localeCompare(b.name));
                html += `
                    <div class="tag-category">
                      <h4>${cat}</h4>
                      <div class="tag-list">
                        ${tags.map(t => `<a href="/?q=${encodeURIComponent(t.name)}" class="tag ${cat} tag-text">${t.name}</a>`).join('')}
                      </div>
                    </div>
                `;
            });
            c.innerHTML = html || '<p class="text-xs text-secondary mb-3">No tags</p>';
            
            // Set initial tags in contenteditable div
            const input = el('tags-input');
            if (input) {
                input.textContent = (m.tags || []).map(t => t.name).join(' ');
                // Pre-validate existing tags
                setTimeout(validateAndStyleTags, 100);
            }
        }

        async function renderAIMetadata(m) {
            const section = el('ai-metadata-section');
            const content = el('ai-metadata-content');
            const appendBtn = el('append-ai-tags-btn');

            try {
                // Fetch metadata from the file
                const res = await fetch(`/api/media/${m.id}/metadata`);
                if (!res.ok) {
                    section.style.display = 'none';
                    if (appendBtn) appendBtn.style.display = 'none';
                    return;
                }

                const metadata = await res.json();

                // Look for AI parameters in common fields
                let aiData = null;

                // Check for 'parameters' or 'Parameters' field
                if (metadata.parameters) {
                    aiData = typeof metadata.parameters === 'string' 
                        ? JSON.parse(metadata.parameters) 
                        : metadata.parameters;
                } else if (metadata.Parameters) {
                    aiData = typeof metadata.Parameters === 'string' 
                        ? JSON.parse(metadata.Parameters) 
                        : metadata.Parameters;
                } else if (metadata.prompt) {
                    aiData = typeof metadata.prompt === 'string' 
                        ? JSON.parse(metadata.prompt) 
                        : metadata.prompt;
                }

                // If no AI data found, hide section
                if (!aiData || Object.keys(aiData).length === 0) {
                    section.style.display = 'none';
                    if (appendBtn) appendBtn.style.display = 'none';
                    return;
                }

                // Show append button if AI prompt exists and admin mode is on
                if (app.isAdminMode && appendBtn && aiData) {
                    appendBtn.style.display = 'block';
                }

                // Generate HTML
                let html = '';

                Object.entries(aiData).forEach(([key, value]) => {
                    const sectionTitle = formatKey(key);

                    html += `<div class="ai-section mb-3">`;
                    html += `<h4 class="text-xs font-bold text-[var(--primary-color)] mb-2">${sectionTitle}</h4>`;
                    
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        html += `<div class="ml-2">`;
                        Object.entries(value).forEach(([subKey, subValue]) => {
                            html += `
                                <div class="ai-data-row">
                                    <span class="text-secondary">${formatKey(subKey)}:</span>
                                    <div class="text" style="text-align: right; flex: 1;">${formatValue(subValue, true)}</div>
                                </div>
                            `;
                        });
                        html += `</div>`;
                    } else {
                        html += `<div class="text ml-2">${formatValue(value, true)}</div>`;
                    }

                    html += `</div>`;
                });

                content.innerHTML = html;
                section.style.display = 'block';

                // Add event listeners to expandable text elements
                setupExpandableListeners();
            } catch (e) {
                console.error('Error rendering AI metadata:', e);
                section.style.display = 'none';
            }
        }

        function formatKey(key) {
            // Convert snake_case or camelCase to Title Case
            return key
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .replace(/\b\w/g, c => c.toUpperCase())
                .replace(/Cfgscale/g, 'CFG Scale')
                .replace(/Cfg Scale/g, 'CFG Scale')
                .replace(/Vae/g, 'VAE')
                .replace(/Aspectratio/g, 'Aspect Ratio')
                .replace(/Aspect Ratio/g, 'Aspect Ratio')
                .replace(/Automaticvae/g, 'Automatic VAE')
                .replace(/Automatic Vae/g, 'Automatic VAE')
                .replace(/Negativeprompt/g, 'Negative Prompt')
                .replace(/Negative Prompt/g, 'Negative Prompt');
        }

        function formatValue(value, isExpandable = true) {
            if (typeof value === 'boolean') {
                return value ? 'Yes' : 'No';
            }
            if (typeof value === 'string') {
                // Escape HTML and handle long strings
                const escaped = value.replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // If it's a long text, make it expandable
                if (isExpandable && escaped.length > 100) {
                    const id = 'expand-' + Math.random().toString(36).substr(2, 9);
                    return `
                        <div class="expandable-text" id="${id}-container" style="cursor: pointer; user-select: text;">
                            <span class="text-truncated" id="${id}-truncated">${escaped.substring(0, 100)}...<br><span class="expand-indicator" style="user-select: none;">[click to expand]</span></span>
                            <span class="text-full" id="${id}-full" style="display: none;">${escaped}<br><span class="expand-indicator" style="user-select: none;">[click to collapse]</span></span>
                        </div>
                    `;
                }
                return escaped;
            }
            if (Array.isArray(value)) {
                return value.join(', ');
            }
            return String(value);
        }

        function setupExpandableListeners() {
            // Find all expandable text containers
            document.querySelectorAll('.expandable-text').forEach(container => {
                // Remove any existing listeners to avoid duplicates
                const newContainer = container.cloneNode(true);
                container.parentNode.replaceChild(newContainer, container);

                // Add the click listener
                newContainer.addEventListener('click', function(e) {
                    // Check if text is being selected
                    const selection = window.getSelection();
                    if (selection && selection.toString().length > 0) {
                        // Text is selected, don't toggle
                        return;
                    }

                    // Only proceed if we're not clicking on selected text
                    const id = this.id.replace('-container', '');
                    toggleExpand(id);
                });

                // Prevent double-click from selecting text and triggering expand
                newContainer.addEventListener('dblclick', function(e) {
                    // Allow double-click to select text normally
                    e.stopPropagation();
                });
            });
        }

        window.toggleExpand = function(id) {
            const truncated = document.getElementById(id + '-truncated');
            const full = document.getElementById(id + '-full');

            if (full.style.display === 'none') {
                truncated.style.display = 'none';
                full.style.display = 'inline';
            } else {
                truncated.style.display = 'inline';
                full.style.display = 'none';
            }
        }

        function createTooltip() {
            // Create tooltip element if it doesn't exist
            if (!document.getElementById('media-tooltip')) {
                const tooltip = document.createElement('div');
                tooltip.id = 'media-tooltip';
                tooltip.style.cssText = `
                    position: absolute;
                    background: rgba(0, 0, 0, 0.95);
                    color: white;
                    padding: 8px 12px;
                    font-size: 13px;
                    pointer-events: none;
                    z-index: 10000;
                    max-width: 300px;
                    word-wrap: break-word;
                    display: none;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
                `;
                document.body.appendChild(tooltip);
            }
            return document.getElementById('media-tooltip');
        }

        function showTooltip(element, tags, tooltipElement) {
            if (!tags || tags.length === 0) return;

            // Sort tags alphabetically
            const sortedTags = tags
                .map(tag => tag.name || tag)
                .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

            // Create comma-separated list
            const tagList = sortedTags.join(', ');

            tooltipElement.textContent = tagList;
            tooltipElement.style.display = 'block';

            // Position tooltip
            positionTooltip(element, tooltipElement);
        }

        function positionTooltip(element, tooltipElement) {
            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltipElement.getBoundingClientRect();

            // Calculate position (above the element by default)
            let top = rect.top - tooltipRect.height - 10;
            let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

            // If tooltip would go off top of screen, show below instead
            if (top < 10) {
                top = rect.bottom + 10;
            }

            // Keep tooltip within viewport horizontally
            if (left < 10) {
                left = 10;
            } else if (left + tooltipRect.width > window.innerWidth - 10) {
                left = window.innerWidth - tooltipRect.width - 10;
            }

            // Add scroll offset
            top += window.scrollY;
            left += window.scrollX;

            tooltipElement.style.top = `${top}px`;
            tooltipElement.style.left = `${left}px`;
        }

        function hideTooltip(tooltipElement) {
            if (tooltipElement) {
                tooltipElement.style.display = 'none';
            }
        }

        async function loadRelatedMedia() {
            if (!currentMedia || !currentMedia.tags || !currentMedia.tags.length) {
                hideRelatedMedia();
                return;
            }

            let generalTags = currentMedia.tags.filter(t => t.category === 'general');
        
            if (!generalTags.length) {
                hideRelatedMedia();
                return;
            }

            for (let i = generalTags.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [generalTags[i], generalTags[j]] = [generalTags[j], generalTags[i]];
            }

            const numTags = Math.min(2, Math.max(1, Math.floor(Math.random() * generalTags.length) + 1));
            const tagQuery = generalTags.slice(0, numTags).map(t => t.name).join(' ');

            try {
                const res = await fetch(`/api/search?q=${encodeURIComponent(tagQuery)}&limit=12`);
                const data = await res.json();
                const currentMediaId = parseInt(mediaId);
                const items = (data.items || []).filter(i => i.id !== currentMediaId);

                if (items.length === 0) {
                    hideRelatedMedia();
                    return;
                }

                // Show related media section and populate it
                const relatedMediaEl = el('related-media');
                const relatedMediaSection = relatedMediaEl.parentElement;
                const params = new URLSearchParams(window.location.search);
                const queryString = params.toString();
                relatedMediaSection.style.display = 'block';

                // Create the tooltip element if it doesn't exist
                const tooltipElement = createTooltip();
                relatedMediaEl.innerHTML = '';

                // Create media items 
                items.forEach(media => {
                    // Create parent div container
                    const item = document.createElement('div');
                    item.className = `gallery-item ${media.file_type}`;
                    item.dataset.id = media.id;
                    item.dataset.rating = media.rating;

                    // Create link element
                    const link = document.createElement('a');
                    link.href = `/media/${media.id}${queryString ? '?' + queryString : ''}`;

                    // Create image element
                    const img = document.createElement('img');
                    img.src = `/api/media/${media.id}/thumbnail`;
                    img.alt = media.filename;
                    img.loading = 'lazy';
                    img.onerror = () => {
                        console.error('Failed to load thumbnail for media:', media.id);
                        img.src = '/static/images/no-thumbnail.png'; // Fallback image
                    };

                    link.appendChild(img);
                    item.appendChild(link);

                    // Add share icon if shared
                    if (media.is_shared) {
                        const shareIcon = document.createElement('div');
                        shareIcon.className = 'share-icon';
                        shareIcon.textContent = 'SHARED';
                        item.appendChild(shareIcon);
                    }

                    // Add hover events for tooltip on the parent div
                    let hoverTimeout;
                    item.addEventListener('mouseenter', () => {
                        // Add a small delay to prevent tooltip from showing on quick mouseovers
                        hoverTimeout = setTimeout(() => {
                            if (media.tags && media.tags.length > 0) {
                                showTooltip(item, media.tags, tooltipElement);
                            }
                        }, 300);
                    });

                    item.addEventListener('mouseleave', () => {
                        clearTimeout(hoverTimeout);
                        hideTooltip(tooltipElement);
                    });

                    // Update tooltip position on scroll if it's visible
                    window.addEventListener('scroll', () => {
                        if (tooltipElement.style.display === 'block') {
                            positionTooltip(item, tooltipElement);
                        }
                    }, { passive: true });

                    // Append the complete item to related media container
                    relatedMediaEl.appendChild(item);
                });
            } catch (e) {
                console.error('related error', e);
                hideRelatedMedia();
            }
        }

        function hideRelatedMedia() {
            const relatedMediaEl = el('related-media');
            if (relatedMediaEl) {
                // Hide the entire section (parent div that contains heading and grid)
                const relatedMediaSection = relatedMediaEl.parentElement;
                if (relatedMediaSection) {
                    relatedMediaSection.style.display = 'none';
                }
            }
        }

        function formatFileSize(bytes) {
            if (!bytes) return '0 Bytes';
            const k = 1024, sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }
        function formatDuration(s) {
            const m = Math.floor(s / 60), sec = Math.floor(s % 60);
            return `${m}:${String(sec).padStart(2, '0')}`;
        }

        el('edit-tags-form')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const tagsInput = el('tags-input');
            const text = getPlainTextFromDiv(tagsInput);
            const allTags = text.split(/\s+/).filter(t => t.length > 0);
            
            // Filter out invalid tags
            const validTags = [];
            for (const tag of allTags) {
                const normalized = tag.toLowerCase().trim();
                const isValid = tagValidationCache.get(normalized);
                if (isValid !== false) { // Include if valid or unknown
                    validTags.push(tag);
                }
            }
            
            try {
                await app.apiCall(`/api/media/${mediaId}`, { 
                    method: 'PATCH', 
                    body: JSON.stringify({ tags: validTags }) 
                });
                location.reload();
            } catch (e) { 
                app.showNotification(e.message, 'error', 'Error updating tags'); 
            }
        });

        el('rating-select')?.addEventListener('change', async (e) => {
            try {
                await app.apiCall(`/api/media/${mediaId}`, { method: 'PATCH', body: JSON.stringify({ rating: e.target.value }) });
            } catch (e) { app.showNotification(e.message, 'error', 'Error updating rating'); }
        });

        el('share-btn')?.addEventListener('click', async () => {
            try {
                const res = await app.apiCall(`/api/media/${mediaId}/share`, { method: 'POST' });
                showShareLink(res.share_url.split('/').pop(), res.share_ai_metadata);
            } catch (e) { app.showNotification(e.message, 'error', 'Error creating share link'); }
        });
        el('copy-share-link-btn')?.addEventListener('click', () => {
            el('share-link-input').select(); document.execCommand('copy');
        });
        el('unshare-btn')?.addEventListener('click', async () => {
            if (!confirm('Are you sure you want to unshare this media? The share link will stop working.')) {
                return;
            }
            
            try {
                await app.apiCall(`/api/media/${mediaId}/share`, { method: 'DELETE' });
                el('share-link-section').style.display = 'none';
                el('share-btn').style.display = 'block';
                app.showNotification('Media successfully unshared', 'success')
            } catch (e) { app.showNotification(e.message, 'error', 'Error removing share'); }
        });

        el('delete-btn')?.addEventListener('click', async () => {
            if (!confirm('Delete this media?')) return;
            try {
                await app.apiCall(`/api/media/${mediaId}`, { method: 'DELETE' });
                window.location.href = '/';
            } catch (e) { app.showNotification(e.message, 'error', 'Error deleting media'); }
        });

        el('share-ai-metadata-toggle')?.addEventListener('change', async (e) => {
            try {
                await app.apiCall(`/api/media/${mediaId}/share-settings?share_ai_metadata=${e.target.checked}`, { 
                    method: 'PATCH'
                });
                console.log('Share settings updated:', e.target.checked);
            } catch (err) {
                console.error('Error updating share settings:', err);
                app.showNotification(err.message, 'error', 'Error updating share settings');
                // Revert checkbox on error
                e.target.checked = !e.target.checked;
            }
        });

        el('append-ai-tags-btn')?.addEventListener('click', async () => {
            try {
                // Fetch metadata
                const res = await fetch(`/api/media/${mediaId}/metadata`);
                if (!res.ok) {
                    app.showNotification('Could not load AI metadata', 'error');
                    return;
                }
            
                const metadata = await res.json();
                
                let aiPrompt = null;
            
                // Check for prompt in various common structures
                if (metadata.parameters) {
                    const params = typeof metadata.parameters === 'string' 
                        ? JSON.parse(metadata.parameters) 
                        : metadata.parameters;
                    
                    // Check if it's SwarmUI format nested in parameters
                    if (params.sui_image_params && params.sui_image_params.prompt) {
                        aiPrompt = params.sui_image_params.prompt;
                    } else if (params.prompt) {
                        aiPrompt = params.prompt;
                    } else if (params.Prompt) {
                        aiPrompt = params.Prompt;
                    }
                } else if (metadata.Parameters) {
                    const params = typeof metadata.Parameters === 'string' 
                        ? JSON.parse(metadata.Parameters) 
                        : metadata.Parameters;
                    
                    // Check if it's SwarmUI format nested in Parameters
                    if (params.sui_image_params && params.sui_image_params.prompt) {
                        aiPrompt = params.sui_image_params.prompt;
                    } else if (params.prompt) {
                        aiPrompt = params.prompt;
                    } else if (params.Prompt) {
                        aiPrompt = params.Prompt;
                    }
                } else if (metadata.sui_image_params && metadata.sui_image_params.prompt) {
                    // Direct SwarmUI format
                    aiPrompt = metadata.sui_image_params.prompt;
                } else if (metadata.prompt) {
                    aiPrompt = metadata.prompt;
                } else if (metadata.Prompt) {
                    aiPrompt = metadata.Prompt;
                }
            
                // Fallback: search through all nested objects for a prompt field
                if (!aiPrompt) {
                    for (const [key, value] of Object.entries(metadata)) {
                        if (typeof value === 'object' && value !== null) {
                            if (value.prompt) {
                                aiPrompt = value.prompt;
                                break;
                            } else if (value.Prompt) {
                                aiPrompt = value.Prompt;
                                break;
                            } else if (value.sui_image_params && value.sui_image_params.prompt) {
                                aiPrompt = value.sui_image_params.prompt;
                                break;
                            }
                        }
                    }
                }
            
                if (!aiPrompt || typeof aiPrompt !== 'string') {
                    app.showNotification('No AI prompt found in metadata', 'error');
                    return;
                }
            
                // Parse the prompt: split by comma, replace spaces with underscores in each tag
                const promptTags = aiPrompt
                    .split(',')
                    .map(tag => tag.trim().replace(/\s+/g, '_'))
                    .filter(tag => tag.length > 0);
            
                // Validate each tag and get the correct tag name (handling aliases)
                const validTags = [];
                for (const tag of promptTags) {
                    const validTag = await getTagOrAlias(tag);
                    if (validTag) {
                        validTags.push(validTag);
                    }
                }
            
                if (validTags.length === 0) {
                    app.showNotification('No valid tags found in AI prompt', 'error');
                    return;
                }
            
                // Get current tags from input
                const tagsInput = el('tags-input');
                const currentText = getPlainTextFromDiv(tagsInput).trim();
                const currentTags = currentText ? currentText.split(/\s+/) : [];
            
                // Merge: add only new tags that aren't already present
                const existingTagsSet = new Set(currentTags.map(t => t.toLowerCase()));
                const newTags = validTags.filter(tag => !existingTagsSet.has(tag.toLowerCase()));
            
                if (newTags.length === 0) {
                    app.showNotification('All AI tags are already present', 'info');
                    return;
                }
            
                // Append new tags
                const allTags = [...currentTags, ...newTags];
                tagsInput.textContent = allTags.join(' ');
            
                // Trigger validation
                await validateAndStyleTags();
            
                app.showNotification(`Appended ${newTags.length} tag(s) from AI prompt`, 'success');
            
            } catch (e) {
                console.error('Error appending AI tags:', e);
                app.showNotification('Error processing AI tags: ' + e.message, 'error');
            }
        });

        function showShareLink(uuid, shareAIMetadata) {
            el('share-link-input').value = `${window.location.origin}/shared/${uuid}`;
            el('share-link-section').style.display = 'block';
            el('share-btn').style.display = 'none';

            // Set checkbox state
            const aiMetadataToggle = el('share-ai-metadata-toggle');
            if (aiMetadataToggle) {
                aiMetadataToggle.checked = shareAIMetadata || false;
            }
        }

        loadMedia();
    });
</script>
{% endblock %}
