{% extends "base.html" %}

{% block title %}Media - {{ app_name }}{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-4">
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-4">
        <!-- Media Content -->
        <div class="lg:col-span-3">
            <div class="surface p-4 border">
                <div id="media-container" class="text-center"></div>
            </div>
            
            <!-- Related Media -->
            <div class="mt-6">
                <h2 class="text-base font-bold mb-3 pb-2 border-b">Related Media</h2>
                <div id="related-media" class="grid grid-cols-4 md:grid-cols-6 gap-2"></div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="lg:col-span-1">
            <!-- Information -->
            <div class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">Information</h3>
                <div id="media-info-content" class="text-xs"></div>
            </div>
            
            <!-- Tags -->
            <div class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">Tags</h3>
                <div id="tags-container"></div>
                
                <!-- Edit Tags (Admin Mode Only) -->
                <div id="edit-tags-section" style="display: none;" class="mt-3 pt-3 border-t">
                    <form id="edit-tags-form">
                        <label class="block text-xs font-bold mb-2">Edit Tags</label>
                        <div class="mb-2" style="position: relative;">
                            <div id="tags-input" contenteditable="true" data-placeholder="original highres cat_ears" class="w-full bg px-2 py-1 border text-xs focus:outline-none focus:border-primary" style="min-height: 1.5rem; white-space: pre-wrap; overflow-wrap: break-word;"></div>
                        </div>
                        <button type="submit" class="w-full px-3 py-1 bg-primary primary-text hover:bg-primary text-xs">Save Tags</button>
                    </form>
                </div>
            </div>

            <!-- AI Metadata (if present) -->
            <div id="ai-metadata-section" style="display: none;" class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">AI Generation Data</h3>
                <div id="ai-metadata-content" class="text-xs"></div>
            </div>
            
            <!-- Actions -->
            <div class="surface p-3 border mb-4">
                <h3 class="text-sm font-bold mb-3 pb-2 border-b">Actions</h3>
                
                <div class="space-y-3">
                    <a id="download-btn" href="#" download class="block w-full px-3 py-1 surface-light hover:surface-light text text-center text-xs">Download</a>
                    
                    <!-- Admin Actions -->
                    <div id="admin-actions" style="display: none;" class="space-y-2 pt-2 border-t">
                        <label class="block text-xs font-bold mb-1">Rating</label>
                        <select id="rating-select" class="w-full bg px-2 py-1 border text-xs mb-2 focus:outline-none focus:border-primary">
                            <option value="safe">Safe</option>
                            <option value="questionable">Questionable</option>
                            <option value="explicit">Explicit</option>
                        </select>
                        
                        <button id="share-btn" class="w-full px-3 py-1 bg-primary primary-text hover:bg-primary text-xs">Share</button>
                        <button id="delete-btn" class="w-full px-3 py-1 bg-danger hover:bg-danger tag-text text-xs">Delete</button>
                    </div>
                </div>
            </div>
            
            <!-- Share Link Display -->
            <div id="share-link-section" style="display: none;" class="bg-primary primary-text p-3 border border-primary mb-4">
                <h4 class="text-sm font-bold mb-2 primary-text">Share Actions</h4>
                <div class="mb-2 p-2 surface border">
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-xs text font-medium">Include AI metadata</span>
                        <div class="relative">
                            <input type="checkbox" id="share-ai-metadata-toggle" class="sr-only peer">
                            <div class="w-9 h-5 surface-light peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-[var(--primary-color)] rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-[var(--primary-text)] after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-[var(--text)] after:border-[var(--surface-light)] after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-[var(--primary-color)] peer-checked:after:bg-[var(--primary-text)]"></div>
                        </div>
                    </label>
                </div>
                <input type="text" id="share-link-input" readonly class="w-full surface px-2 py-1 border focus:outline-none focus:border-primary text-xs mb-2">
                <div class="space-y-1">
                    <button id="copy-share-link-btn" class="w-full px-3 py-1 surface hover:surface text text-xs">Copy Link</button>
                    <button id="unshare-btn" class="w-full px-3 py-1 surface-light hover:surface-light text text-xs" style="display: none;">Remove Share</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const mediaId = "{{ media_id }}";
        let currentMedia = null;

        const el = id => document.getElementById(id);

        // Tag validation system
        const tagValidationCache = new Map(); // tag -> boolean
        let validationTimeout = null;

        async function checkTagExists(tagName) {
            if (!tagName || !tagName.trim()) return true;
            const normalized = tagName.toLowerCase().trim();
            
            try {
                const res = await fetch(`/api/tags/${encodeURIComponent(normalized)}`);
                return res.ok;
            } catch (e) {
                console.error('Error checking tag:', e);
                return false;
            }
        }

        function getPlainTextFromDiv(div) {
            return div.textContent || '';
        }

        function getCursorPosition(element) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return 0;
            
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            
            return preCaretRange.toString().length;
        }

        function setCursorPosition(element, offset) {
            const selection = window.getSelection();
            const range = document.createRange();
            
            let currentOffset = 0;
            let found = false;
            
            function traverseNodes(node) {
                if (found) return;
                
                if (node.nodeType === Node.TEXT_NODE) {
                    const nodeLength = node.textContent.length;
                    if (currentOffset + nodeLength >= offset) {
                        range.setStart(node, offset - currentOffset);
                        range.collapse(true);
                        found = true;
                        return;
                    }
                    currentOffset += nodeLength;
                } else {
                    for (let child of node.childNodes) {
                        traverseNodes(child);
                        if (found) return;
                    }
                }
            }
            
            try {
                traverseNodes(element);
                if (!found && element.lastChild) {
                    range.setStartAfter(element.lastChild);
                    range.collapse(true);
                }
                selection.removeAllRanges();
                selection.addRange(range);
            } catch (e) {
                console.error('Error setting cursor:', e);
            }
        }

        async function validateAndStyleTags() {
            const tagsInput = el('tags-input');
            if (!tagsInput) return;
            
            const text = getPlainTextFromDiv(tagsInput);
            const cursorPos = getCursorPosition(tagsInput);
            
            // Split by whitespace
            const parts = text.split(/(\s+)/);
            const tags = [];
            
            // Check each non-whitespace part
            for (let part of parts) {
                if (part.trim()) {
                    const normalized = part.trim().toLowerCase();
                    if (!tagValidationCache.has(normalized)) {
                        const exists = await checkTagExists(normalized);
                        tagValidationCache.set(normalized, exists);
                    }
                    tags.push({ text: part, isValid: tagValidationCache.get(normalized) });
                } else {
                    tags.push({ text: part, isWhitespace: true });
                }
            }
            
            // Build styled HTML
            let html = '';
            for (let tag of tags) {
                if (tag.isWhitespace) {
                    html += tag.text;
                } else if (tag.isValid === false) {
                    html += `<span class="invalid-tag">${tag.text}</span>`;
                } else {
                    html += tag.text;
                }
            }
            
            // Update content if changed
            if (tagsInput.innerHTML !== html) {
                tagsInput.innerHTML = html || '';
                setCursorPosition(tagsInput, cursorPos);
            }
        }

        function setupTagInput() {
            const tagsInput = el('tags-input');
            if (!tagsInput) return;
            
            // Handle input events
            tagsInput.addEventListener('input', () => {
                clearTimeout(validationTimeout);
                validationTimeout = setTimeout(validateAndStyleTags, 300);
            });
            
            // Immediate validation on space
            tagsInput.addEventListener('keyup', (e) => {
                if (e.key === ' ') {
                    clearTimeout(validationTimeout);
                    validateAndStyleTags();
                }
            });
            
            // Prevent default Enter behavior (creating new lines)
            tagsInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                }
            });
            
            // Paste as plain text
            tagsInput.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = e.clipboardData.getData('text/plain');
                document.execCommand('insertText', false, text);
            });
        }

        async function loadMedia() {
            try {
                const res = await fetch(`/api/media/${mediaId}`);
                currentMedia = await res.json();
                renderMedia(currentMedia);
                renderInfo(currentMedia);
                renderTags(currentMedia);
                await renderAIMetadata(currentMedia);
                if (app.isAdminMode) {
                    el('edit-tags-section').style.display = 'block';
                    el('admin-actions').style.display = 'block';
                    el('unshare-btn').style.display = 'block';
                    setupTagInput();
                    
                    // Initialize tag autocomplete with contenteditable support
                    const tagsInput = document.getElementById('tags-input');
                    if (tagsInput) {
                        new TagAutocomplete(tagsInput, {
                            multipleValues: true,
                            onSelect: () => {
                                // Trigger validation after autocomplete selection
                                setTimeout(validateAndStyleTags, 100);
                            }
                        });
                    }
                }
                if (currentMedia.is_shared) {
                    showShareLink(currentMedia.share_uuid, currentMedia.share_ai_metadata);
                }
                await loadRelatedMedia();
            } catch (e) {
                console.error('loadMedia error', e);
            }
        }

        function renderMedia(media) {
            const c = el('media-container');
            c.innerHTML = media.file_type === 'video'
                ? `<video controls><source src="/api/media/${media.id}/file" type="${media.mime_type}"></video>`
                : `<img src="/api/media/${media.id}/file" alt="${media.filename}">`;
            el('download-btn').href = `/api/media/${media.id}/file`;
            el('download-btn').download = media.filename;
        }

        function renderInfo(m) {
            el('media-info-content').innerHTML = `
                <div class="info-row"><span>Filename</span><strong>${m.filename}</strong></div>
                <div class="info-row"><span>Type</span><strong>${m.file_type}</strong></div>
                <div class="info-row"><span>Size</span><strong>${formatFileSize(m.file_size)}</strong></div>
                <div class="info-row"><span>Dimensions</span><strong>${m.width}x${m.height}</strong></div>
                <div class="info-row"><span>Rating</span><strong>${m.rating}</strong></div>
                <div class="info-row"><span>Uploaded</span><strong>${new Date(m.uploaded_at).toLocaleDateString()}</strong></div>
                ${m.duration ? `<div class="info-row"><span>Duration</span><strong>${formatDuration(m.duration)}</strong></div>` : ''}
            `;
            const sel = el('rating-select');
            if (sel) sel.value = m.rating;
        }

        function renderTags(m) {
            const c = el('tags-container');
            const groups = { artist: [], character: [], copyright: [], general: [], meta: [] };
            (m.tags || []).forEach(t => groups[t.category]?.push(t));
            let html = '';
            Object.entries(groups).forEach(([cat, tags]) => {
                if (!tags.length) return;
                tags.sort((a, b) => a.name.localeCompare(b.name));
                html += `
                    <div class="tag-category">
                      <h4>${cat}</h4>
                      <div class="tag-list">
                        ${tags.map(t => `<a href="/?q=${encodeURIComponent(t.name)}" class="tag ${cat} tag-text">${t.name}</a>`).join('')}
                      </div>
                    </div>
                `;
            });
            c.innerHTML = html || '<p class="text-xs text-secondary">No tags</p>';
            
            // Set initial tags in contenteditable div
            const input = el('tags-input');
            if (input) {
                input.textContent = (m.tags || []).map(t => t.name).join(' ');
                // Pre-validate existing tags
                setTimeout(validateAndStyleTags, 100);
            }
        }

        async function renderAIMetadata(m) {
            const section = el('ai-metadata-section');
            const content = el('ai-metadata-content');

            try {
                // Fetch metadata from the file
                const res = await fetch(`/api/media/${m.id}/metadata`);
                if (!res.ok) {
                    section.style.display = 'none';
                    return;
                }

                const metadata = await res.json();

                // Look for AI parameters in common fields
                let aiData = null;

                // Check for 'parameters' or 'Parameters' field
                if (metadata.parameters) {
                    aiData = typeof metadata.parameters === 'string' 
                        ? JSON.parse(metadata.parameters) 
                        : metadata.parameters;
                } else if (metadata.Parameters) {
                    aiData = typeof metadata.Parameters === 'string' 
                        ? JSON.parse(metadata.Parameters) 
                        : metadata.Parameters;
                } else if (metadata.prompt) {
                    aiData = typeof metadata.prompt === 'string' 
                        ? JSON.parse(metadata.prompt) 
                        : metadata.prompt;
                }

                // If no AI data found, hide section
                if (!aiData || Object.keys(aiData).length === 0) {
                    section.style.display = 'none';
                    return;
                }

                // Generate HTML
                let html = '';

                Object.entries(aiData).forEach(([key, value]) => {
                    const sectionTitle = formatKey(key);

                    html += `<div class="ai-section mb-3">`;
                    html += `<h4 class="text-xs font-bold primary-text mb-2">${sectionTitle}</h4>`;
                    
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        html += `<div class="ml-2">`;
                        Object.entries(value).forEach(([subKey, subValue]) => {
                            html += `
                                <div class="ai-data-row">
                                    <span class="text-secondary">${formatKey(subKey)}:</span>
                                    <div class="text" style="text-align: right; flex: 1;">${formatValue(subValue, true)}</div>
                                </div>
                            `;
                        });
                        html += `</div>`;
                    } else {
                        html += `<div class="text ml-2">${formatValue(value, true)}</div>`;
                    }

                    html += `</div>`;
                });

                content.innerHTML = html;
                section.style.display = 'block';

            } catch (e) {
                console.error('Error rendering AI metadata:', e);
                section.style.display = 'none';
            }
        }

        function formatKey(key) {
            // Convert snake_case or camelCase to Title Case
            return key
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .replace(/\b\w/g, c => c.toUpperCase())
                .replace(/Cfgscale/g, 'CFG Scale')
                .replace(/Cfg Scale/g, 'CFG Scale')
                .replace(/Vae/g, 'VAE')
                .replace(/Aspectratio/g, 'Aspect Ratio')
                .replace(/Aspect Ratio/g, 'Aspect Ratio')
                .replace(/Automaticvae/g, 'Automatic VAE')
                .replace(/Automatic Vae/g, 'Automatic VAE')
                .replace(/Negativeprompt/g, 'Negative Prompt')
                .replace(/Negative Prompt/g, 'Negative Prompt');
        }

        function formatValue(value, isExpandable = true) {
            if (typeof value === 'boolean') {
                return value ? 'Yes' : 'No';
            }
            if (typeof value === 'string') {
                // Escape HTML and handle long strings
                const escaped = value.replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // If it's a long text, make it expandable
                if (isExpandable && escaped.length > 100) {
                    const id = 'expand-' + Math.random().toString(36).substr(2, 9);
                    return `
                        <div class="expandable-text" onclick="toggleExpand('${id}')" id="${id}-container">
                            <span class="text-truncated" id="${id}-truncated">${escaped.substring(0, 100)}... <span class="expand-indicator">[click to expand]</span></span>
                            <span class="text-full" id="${id}-full" style="display: none;">${escaped}</span>
                        </div>
                    `;
                }
                return escaped;
            }
            if (Array.isArray(value)) {
                return value.join(', ');
            }
            return String(value);
        }

        window.toggleExpand = function(id) {
            const truncated = document.getElementById(id + '-truncated');
            const full = document.getElementById(id + '-full');

            if (full.style.display === 'none') {
                truncated.style.display = 'none';
                full.style.display = 'inline';
            } else {
                truncated.style.display = 'inline';
                full.style.display = 'none';
            }
        }

        async function loadRelatedMedia() {
            if (!currentMedia || !currentMedia.tags || !currentMedia.tags.length) {
                hideRelatedMedia();
                return;
            }

            let generalTags = currentMedia.tags.filter(t => t.category === 'general');
        
            if (!generalTags.length) {
                hideRelatedMedia();
                return;
            }

            for (let i = generalTags.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [generalTags[i], generalTags[j]] = [generalTags[j], generalTags[i]];
            }

            const numTags = Math.min(2, Math.max(1, Math.floor(Math.random() * generalTags.length) + 1));
            const tagQuery = generalTags.slice(0, numTags).map(t => t.name).join(' ');

            try {
                const res = await fetch(`/api/search?q=${encodeURIComponent(tagQuery)}&limit=12`);
                const data = await res.json();
                const currentMediaId = parseInt(mediaId);
                const items = (data.items || []).filter(i => i.id !== currentMediaId);
                if (items.length === 0) {
                    hideRelatedMedia();
                    return;
                }
                // Show related media section and populate it
                const relatedMediaEl = el('related-media');
                const relatedMediaSection = relatedMediaEl.parentElement;
                const params = new URLSearchParams(window.location.search);
                const queryString = params.toString();
                relatedMediaSection.style.display = 'block';
                relatedMediaEl.innerHTML = items.map(i =>`
                <a href="/media/${i.id}${queryString ? '?' + queryString : ''}" class="gallery-item ${i.file_type}">
                    <img src="/api/media/${i.id}/thumbnail" alt="${i.filename}" loading="lazy">
                </a>
                `).join('');
            } catch (e) {
                console.error('related error', e);
                hideRelatedMedia();
            }
        }

        function hideRelatedMedia() {
            const relatedMediaEl = el('related-media');
            if (relatedMediaEl) {
                // Hide the entire section (parent div that contains heading and grid)
                const relatedMediaSection = relatedMediaEl.parentElement;
                if (relatedMediaSection) {
                    relatedMediaSection.style.display = 'none';
                }
            }
        }

        function formatFileSize(bytes) {
            if (!bytes) return '0 Bytes';
            const k = 1024, sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }
        function formatDuration(s) {
            const m = Math.floor(s / 60), sec = Math.floor(s % 60);
            return `${m}:${String(sec).padStart(2, '0')}`;
        }

        el('edit-tags-form')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const tagsInput = el('tags-input');
            const text = getPlainTextFromDiv(tagsInput);
            const allTags = text.split(/\s+/).filter(t => t.length > 0);
            
            // Filter out invalid tags
            const validTags = [];
            for (const tag of allTags) {
                const normalized = tag.toLowerCase().trim();
                const isValid = tagValidationCache.get(normalized);
                if (isValid !== false) { // Include if valid or unknown
                    validTags.push(tag);
                }
            }
            
            try {
                await app.apiCall(`/api/media/${mediaId}`, { 
                    method: 'PATCH', 
                    body: JSON.stringify({ tags: validTags }) 
                });
                location.reload();
            } catch (e) { 
                app.showNotification(e.message, 'error', 'Error updating tags'); 
            }
        });

        el('rating-select')?.addEventListener('change', async (e) => {
            try {
                await app.apiCall(`/api/media/${mediaId}`, { method: 'PATCH', body: JSON.stringify({ rating: e.target.value }) });
            } catch (e) { app.showNotification(e.message, 'error', 'Error updating rating'); }
        });

        el('share-btn')?.addEventListener('click', async () => {
            try {
                const res = await app.apiCall(`/api/media/${mediaId}/share`, { method: 'POST' });
                showShareLink(res.share_url.split('/').pop(), res.share_ai_metadata);
            } catch (e) { app.showNotification(e.message, 'error', 'Error creating share link'); }
        });
        el('copy-share-link-btn')?.addEventListener('click', () => {
            el('share-link-input').select(); document.execCommand('copy');
        });
        el('unshare-btn')?.addEventListener('click', async () => {
            try {
                await app.apiCall(`/api/media/${mediaId}/share`, { method: 'DELETE' });
                el('share-link-section').style.display = 'none';
                el('share-btn').style.display = 'block';
            } catch (e) { app.showNotification(e.message, 'error', 'Error removing share'); }
        });

        el('delete-btn')?.addEventListener('click', async () => {
            if (!confirm('Delete this media?')) return;
            try {
                await app.apiCall(`/api/media/${mediaId}`, { method: 'DELETE' });
                window.location.href = '/';
            } catch (e) { app.showNotification(e.message, 'error', 'Error deleting media'); }
        });

        el('share-ai-metadata-toggle')?.addEventListener('change', async (e) => {
            try {
                await app.apiCall(`/api/media/${mediaId}/share-settings?share_ai_metadata=${e.target.checked}`, { 
                    method: 'PATCH'
                });
                console.log('Share settings updated:', e.target.checked);
            } catch (err) {
                console.error('Error updating share settings:', err);
                app.showNotification(err.message, 'error', 'Error updating share settings');
                // Revert checkbox on error
                e.target.checked = !e.target.checked;
            }
        });

        function showShareLink(uuid, shareAIMetadata) {
            el('share-link-input').value = `${window.location.origin}/shared/${uuid}`;
            el('share-link-section').style.display = 'block';
            el('share-btn').style.display = 'none';

            // Set checkbox state
            const aiMetadataToggle = el('share-ai-metadata-toggle');
            if (aiMetadataToggle) {
                aiMetadataToggle.checked = shareAIMetadata || false;
            }
        }

        loadMedia();
    });
</script>
{% endblock %}
